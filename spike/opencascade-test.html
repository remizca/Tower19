<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCascade.js WASM Spike Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #7f8c8d;
            margin-bottom: 30px;
        }
        .metric {
            background: #ecf0f1;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }
        .metric-label {
            font-weight: bold;
            color: #2c3e50;
        }
        .metric-value {
            color: #27ae60;
            font-size: 1.2em;
            margin-left: 10px;
        }
        .status {
            padding: 8px 16px;
            border-radius: 4px;
            display: inline-block;
            margin: 10px 0;
            font-weight: bold;
        }
        .status-loading {
            background: #f39c12;
            color: white;
        }
        .status-success {
            background: #27ae60;
            color: white;
        }
        .status-error {
            background: #e74c3c;
            color: white;
        }
        .log {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .log-entry {
            margin: 5px 0;
            padding: 3px 0;
        }
        .log-time {
            color: #95a5a6;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: background 0.3s;
        }
        button:hover {
            background: #2980b9;
        }
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        .operations {
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>OpenCascade.js WASM Spike Test</h1>
        <p class="subtitle">Performance benchmark for Tower19 CAD kernel migration evaluation</p>
        
        <div id="status" class="status status-loading">Initializing...</div>
        
        <div class="metric">
            <span class="metric-label">WASM Load Time:</span>
            <span id="loadTime" class="metric-value">--</span>
        </div>
        
        <div class="metric">
            <span class="metric-label">Init Time:</span>
            <span id="initTime" class="metric-value">--</span>
        </div>
        
        <div class="metric">
            <span class="metric-label">Bundle Size:</span>
            <span id="bundleSize" class="metric-value">~64 MB (unpacked)</span>
        </div>
        
        <div class="operations">
            <h3>Geometry Operations</h3>
            <button id="btnBox" disabled>Create Box</button>
            <button id="btnCylinder" disabled>Create Cylinder</button>
            <button id="btnBoolean" disabled>Boolean Subtract</button>
            <button id="btnFillet" disabled>Apply Fillet</button>
            <button id="btnMeshExport" disabled>Export Mesh</button>
            <button id="btnBenchmark" disabled style="background:#8e44ad">Run Benchmark Suite</button>
            <button id="btnExportJson" disabled style="background:#16a085">Export JSON</button>
        </div>
        
        <div class="metric">
            <span class="metric-label">Last Operation Time:</span>
            <span id="opTime" class="metric-value">--</span>
        </div>
        
        <div class="log" id="log"></div>
    </div>

    <script type="module">
        const logEl = document.getElementById('log');
        const statusEl = document.getElementById('status');
        const loadTimeEl = document.getElementById('loadTime');
        const initTimeEl = document.getElementById('initTime');
        const opTimeEl = document.getElementById('opTime');
        
        // Basic environment diagnostics
        logEl.insertAdjacentHTML('beforeend', `<div class="log-entry"><span class="log-time">[${new Date().toLocaleTimeString()}]</span> Page URL: ${location.href}</div>`);
        logEl.insertAdjacentHTML('beforeend', `<div class="log-entry"><span class="log-time">[${new Date().toLocaleTimeString()}]</span> User-Agent: ${navigator.userAgent}</div>`);
        window.addEventListener('error', (e) => {
            const msg = e?.message || 'Unknown script error';
            const src = e?.filename ? ` (${e.filename}:${e.lineno}:${e.colno})` : '';
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${new Date().toLocaleTimeString()}]</span> GlobalError: ${msg}${src}`;
            logEl.appendChild(entry);
        });
        window.addEventListener('unhandledrejection', (e) => {
            const reason = e?.reason?.message || JSON.stringify(e.reason);
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${new Date().toLocaleTimeString()}]</span> UnhandledRejection: ${reason}`;
            logEl.appendChild(entry);
        });
        
        let oc = null;
        let currentShape = null;
        const metrics = { primitives: {}, boolean: null, fillet: null, mesh: null };
        let lastMeshData = null;
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${timestamp}]</span> ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }
        
        function updateStatus(message, type) {
            statusEl.textContent = message;
            statusEl.className = `status status-${type}`;
        }
        
        function enableButtons() {
            document.querySelectorAll('button').forEach(btn => btn.disabled = false);
        }
        
        async function initOpenCascade() {
            const startLoad = performance.now();
            log('Starting dynamic import of opencascade.js ...');
            try {
            // Prefer importing our TS wrapper to simplify resolution
            const { loadOC } = await import('./oc-init.ts');
                const loadEnd = performance.now();
                const loadTime = (loadEnd - startLoad).toFixed(2);
                loadTimeEl.textContent = `${loadTime} ms`;
                log(`Module imported in ${loadTime} ms`);
                
                const initStart = performance.now();
            log('Initializing OpenCascade instance via loadOC() ...');
            const result = await loadOC();
            oc = result.oc;
                const initEnd = performance.now();
                const initTime = (initEnd - initStart).toFixed(2);
                initTimeEl.textContent = `${initTime} ms`;
                log(`OpenCascade initialized in ${initTime} ms`);
                
                const totalTime = (initEnd - startLoad).toFixed(2);
                log(`Total time to ready: ${totalTime} ms`, 'success');
                updateStatus('Ready', 'success');
                enableButtons();
                
                const totalSeconds = totalTime / 1000;
                if (totalSeconds < 2.0) {
                    log(`✓ PASS: Init time ${totalSeconds.toFixed(2)}s < 2s threshold`, 'success');
                } else {
                    log(`✗ FAIL: Init time ${totalSeconds.toFixed(2)}s exceeds 2s threshold`, 'error');
                }
            } catch (moduleError) {
                // If the bare specifier fails (e.g., path resolution), attempt a fallback relative path import
                log(`Primary import failed: ${moduleError.message}. Trying fallback path...`, 'error');
                try {
                    const fallbackStart = performance.now();
                    // Fallback to direct dist path usage
                    const wasmModule = await import('../node_modules/opencascade.js/dist/opencascade.wasm.js');
                    const fallbackLoadEnd = performance.now();
                    const loadTime = (fallbackLoadEnd - startLoad).toFixed(2);
                    loadTimeEl.textContent = `${loadTime} ms (fallback)`;
                    log(`Fallback module imported in ${loadTime} ms`);
                    const initStart = performance.now();
                    oc = new wasmModule.default({
                        locateFile(path) {
                            if (path.endsWith('.wasm')) return '../node_modules/opencascade.js/dist/opencascade.wasm.wasm';
                            return path;
                        }
                    });
                    await oc.ready; // Wait for emscripten ready promise if present
                    const initEnd = performance.now();
                    const initTime = (initEnd - initStart).toFixed(2);
                    initTimeEl.textContent = `${initTime} ms (fallback)`;
                    const totalTime = (initEnd - startLoad).toFixed(2);
                    log(`Total time to ready (fallback): ${totalTime} ms`, 'success');
                    updateStatus('Ready (fallback)', 'success');
                    enableButtons();
                } catch (fallbackError) {
                    log(`ERROR loading OpenCascade (fallback also failed): ${fallbackError.message}`, 'error');
                    updateStatus('Failed to load', 'error');
                    console.error(fallbackError);
                }
            }
        }
        
        // Geometry operation handlers
        function makeBox(w, h, d){
            // Try dimension-only overload first (_1)
            if (oc.BRepPrimAPI_MakeBox_1){
                return new oc.BRepPrimAPI_MakeBox_1(w, h, d);
            }
            // Fallback: maybe overload with origin point then dimensions (guessing signature)
            if (oc.BRepPrimAPI_MakeBox_2){
                // Try with origin coordinates (0,0,0,w,h,d) if 6 params expected; else with 4 (w,h,d,0)
                try {
                    return new oc.BRepPrimAPI_MakeBox_2(w, h, d, 0);
                } catch(e){
                    try { return new oc.BRepPrimAPI_MakeBox_2(0,0,0,w,h,d); } catch(e2){ throw e2; }
                }
            }
            throw new Error('No supported MakeBox overload found');
        }

        document.getElementById('btnBox').addEventListener('click', () => {
            const start = performance.now();
            try {
                const box = makeBox(100,50,30);
                currentShape = box.Shape();
                const time = (performance.now() - start).toFixed(2);
                opTimeEl.textContent = `${time} ms`;
                log(`Created box (100x50x30) in ${time} ms`);
                metrics.primitives.box = parseFloat(time);
            } catch (error) {
                log(`Box creation error: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('btnCylinder').addEventListener('click', () => {
            const start = performance.now();
            try {
                // Use radius/height only overload (_1) if available
                let cylinder;
                if (oc.BRepPrimAPI_MakeCylinder_1) {
                    cylinder = new oc.BRepPrimAPI_MakeCylinder_1(25, 80);
                } else if (oc.BRepPrimAPI_MakeCylinder_2) {
                    // Fallback guess: axis + radius + height (provide third orientation dir if needed)
                    const axis = new oc.gp_Ax2_2(new oc.gp_Pnt_3(0,0,0), new oc.gp_Dir_4(0,0,1), new oc.gp_Dir_4(1,0,0));
                    cylinder = new oc.BRepPrimAPI_MakeCylinder_2(axis, 25, 80);
                } else {
                    throw new Error('No supported cylinder overload found');
                }
                currentShape = cylinder.Shape();
                const time = (performance.now() - start).toFixed(2);
                opTimeEl.textContent = `${time} ms`;
                log(`Created cylinder (r=25, h=80) in ${time} ms`);
                metrics.primitives.cylinder = parseFloat(time);
            } catch (error) {
                log(`Cylinder creation error: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('btnBoolean').addEventListener('click', () => {
            const start = performance.now();
            try {
                // Create box using helper
                const box = makeBox(100,100,50);
                const boxShape = box.Shape();
                
                // Create cylinder hole (use simple overload, then translate to center)
                let cylinder;
                if (oc.BRepPrimAPI_MakeCylinder_1){
                    cylinder = new oc.BRepPrimAPI_MakeCylinder_1(20, 50);
                } else if (oc.BRepPrimAPI_MakeCylinder_2) {
                    const axisHole = new oc.gp_Ax2_2(new oc.gp_Pnt_3(50,50,0), new oc.gp_Dir_4(0,0,1), new oc.gp_Dir_4(1,0,0));
                    cylinder = new oc.BRepPrimAPI_MakeCylinder_2(axisHole, 20, 50);
                } else {
                    throw new Error('No cylinder overload available for boolean');
                }
                let cylShape = cylinder.Shape();
                if (oc.gp_Trsf_1 && oc.BRepBuilderAPI_Transform_2 && oc.gp_Vec_4) {
                    // Translate cylinder to center of box if using radius/height only overload placed at origin
                    const tr = new oc.gp_Trsf_1();
                    tr.SetTranslation_1(new oc.gp_Vec_4(50,50,0));
                    const mover = new oc.BRepBuilderAPI_Transform_2(cylShape, tr, false);
                    cylShape = mover.Shape();
                }
                
                // Boolean subtract
                const cut = new oc.BRepAlgoAPI_Cut_1(boxShape, cylShape);
                currentShape = cut.Shape();
                
                const time = (performance.now() - start).toFixed(2);
                opTimeEl.textContent = `${time} ms`;
                log(`Boolean subtract (box - cylinder) in ${time} ms`);
                metrics.boolean = parseFloat(time);
            } catch (error) {
                log(`Boolean operation error: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('btnFillet').addEventListener('click', () => {
            if (!currentShape) {
                log('No shape available. Create geometry first.', 'error');
                return;
            }
            
            const start = performance.now();
            try {
                const fillet = new oc.BRepFilletAPI_MakeFillet(currentShape, oc.ChFi3d_FilletShape.ChFi3d_Rational);
                
                // Iterate edges and add fillets
                const explorer = new oc.TopExp_Explorer_2(currentShape, oc.TopAbs_ShapeEnum.TopAbs_EDGE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);
                let edgeCount = 0;
                while (explorer.More()) {
                    const edge = oc.TopoDS.Edge_1(explorer.Current());
                    fillet.Add_2(5, edge); // 5mm fillet radius
                    edgeCount++;
                    explorer.Next();
                }
                
                currentShape = fillet.Shape();
                const time = (performance.now() - start).toFixed(2);
                opTimeEl.textContent = `${time} ms`;
                log(`Applied 5mm fillets to ${edgeCount} edges in ${time} ms`);
                metrics.fillet = { time: parseFloat(time), edges: edgeCount };
            } catch (error) {
                log(`Fillet error: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('btnMeshExport').addEventListener('click', () => {
            if (!currentShape) {
                log('No shape available. Create geometry first.', 'error');
                return;
            }
            
            const start = performance.now();
            try {
                // Triangulate the shape
                const triangulation = new oc.BRepMesh_IncrementalMesh_2(currentShape, 0.1, false, 0.5, true);
                
                let vertexCount = 0;
                let triangleCount = 0;
                
                // Explore faces and extract mesh data
                const explorer = new oc.TopExp_Explorer_2(currentShape, oc.TopAbs_ShapeEnum.TopAbs_FACE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);
                while (explorer.More()) {
                    const face = oc.TopoDS.Face_1(explorer.Current());
                    const location = new oc.TopLoc_Location_1();
                    const triangles = oc.BRep_Tool.Triangulation(face, location);
                    
                    if (!triangles.IsNull()) {
                        vertexCount += triangles.get().NbNodes();
                        triangleCount += triangles.get().NbTriangles();
                    }
                    
                    explorer.Next();
                }
                
                const time = (performance.now() - start).toFixed(2);
                opTimeEl.textContent = `${time} ms`;
                log(`Mesh export: ${vertexCount} vertices, ${triangleCount} triangles in ${time} ms`);
                metrics.mesh = { time: parseFloat(time), vertices: vertexCount, triangles: triangleCount };

                // Build lightweight triangles array (indices only) for potential downstream use
                lastMeshData = collectMeshTriangles(currentShape);
                log(`Collected ${lastMeshData.triangles.length} triangle records.`);
            } catch (error) {
                log(`Mesh export error: ${error.message}`, 'error');
            }
        });

        // Automated benchmark sequence
        document.getElementById('btnBenchmark').addEventListener('click', async () => {
            log('Starting automated benchmark suite...');
            const seqStart = performance.now();
            document.getElementById('btnBoolean').click(); // sets currentShape to cut result
            await new Promise(r => setTimeout(r, 50));
            document.getElementById('btnFillet').click();
            await new Promise(r => setTimeout(r, 50));
            document.getElementById('btnMeshExport').click();
            const seqEnd = performance.now();
            const total = (seqEnd - seqStart).toFixed(2);
            log(`Benchmark sequence total time (excluding init): ${total} ms`);
                const summary = {
                    init: initTimeEl.textContent,
                    load: loadTimeEl.textContent,
                    primitives: metrics.primitives,
                    boolean: metrics.boolean,
                    fillet: metrics.fillet,
                    mesh: metrics.mesh,
                    sequenceMs: parseFloat(total),
                    memory: captureMemorySnapshot()
                };
            log(`SUMMARY: ${JSON.stringify(summary, null, 2)}`);
            console.table(summary);
            enableExport();
        });

        // Export JSON of benchmark + mesh data
        document.getElementById('btnExportJson').addEventListener('click', () => {
            if(!metrics.mesh) {
                log('Run benchmark / mesh export first before JSON export.', 'error');
                return;
            }
            const payload = {
                timestamp: new Date().toISOString(),
                summary: {
                    initMs: parseFloat(initTimeEl.textContent),
                    loadMs: parseFloat(loadTimeEl.textContent),
                    primitives: metrics.primitives,
                    booleanMs: metrics.boolean,
                    fillet: metrics.fillet,
                    mesh: metrics.mesh,
                    memory: captureMemorySnapshot()
                },
                mesh: lastMeshData
            };
            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'occt-benchmark.json';
            a.click();
            URL.revokeObjectURL(a.href);
            log('Exported occt-benchmark.json');
        });

        function enableExport(){
            document.getElementById('btnExportJson').disabled = false;
        }

        // Collect triangles & vertices from triangulation for downstream conversion
        function collectMeshTriangles(shape){
            const explorer = new oc.TopExp_Explorer_2(shape, oc.TopAbs_ShapeEnum.TopAbs_FACE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);
            const faces = [];
            while(explorer.More()) {
                const face = oc.TopoDS.Face_1(explorer.Current());
                const loc = new oc.TopLoc_Location_1();
                const tri = oc.BRep_Tool.Triangulation(face, loc);
                if(!tri.IsNull()) {
                    const handle = tri.get();
                    const nodes = handle.Nodes();
                    const tris = handle.Triangles();
                    const faceData = { vertices: [], triangles: [] };
                    for(let i=1;i<=handle.NbNodes();i++) {
                        const p = nodes.Value(i);
                        faceData.vertices.push([p.X(), p.Y(), p.Z()]);
                    }
                    for(let i=1;i<=handle.NbTriangles();i++) {
                        const t = tris.Value(i);
                        faceData.triangles.push([t.Value(1), t.Value(2), t.Value(3)]);
                    }
                    faces.push(faceData);
                }
                explorer.Next();
            }
            return { faces, triangles: faces.flatMap(f=>f.triangles), vertexCount: faces.reduce((a,f)=>a+f.vertices.length,0) };
        }

        function captureMemorySnapshot(){
            const mem = (performance && performance.memory) ? performance.memory : null;
            if(!mem) return { supported:false };
            return {
                supported:true,
                jsHeapSizeLimit: mem.jsHeapSizeLimit,
                totalJSHeapSize: mem.totalJSHeapSize,
                usedJSHeapSize: mem.usedJSHeapSize
            };
        }
        
        // Initialize on page load
        log('OpenCascade.js WASM Spike Test Started');
        log('Testing bundle: opencascade.js v1.1.1');
        initOpenCascade();
        // Auto-run benchmark after ready (poll until oc is set)
        const auto = setInterval(()=>{
            if(oc){
                clearInterval(auto);
                log('Auto-triggering benchmark suite...');
                document.getElementById('btnBenchmark').click();
            }
        },200);
    </script>
</body>
</html>
